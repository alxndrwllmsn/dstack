"""
Functions used to generate diagnostics plots for the pipeline output.
Namely to plot the SoFiA source finding detections. Note that SoFiA
generates .fits output images, and so this module also includes functions
to handle .fits images. The code should be called within a ``RadioPadre`` notebook!

The formulas used in this module to generate the analytics plots are from
Meyer et al. 2017 (https://arxiv.org/abs/1705.04210)

Therefore for the detailed explanations for the computations, dee Meyer et al. 2017

Some simple functions defined here only for the source analytics. Nd so
these scripts are designed to handle the SoFiA output of HI sources.
"""

__all__ = ['add_inner_title', 'get_source_files', 'get_N_sources', 'get_z_from_freq',
        'get_velocity_from_freq', 'get_velocity_dispersion_from_freq', 'get_column_density',
        'get_column_density_sensitivity', 'get_freq_and_redshift_from_catalog', 'get_RMS_from_catalog',
        'fget_wcs', 'fget_beam', 'fget_channel_width', 'get_optical_image', 'get_optical_image_ndarray',
        'get_momN_ndarray', 'get_spectra_array', 'plot_optical_background_with_mom0_conturs',
        'plot_momN_map', 'plot_spectra', 'source_analytics_plot',
        'create_complementary_figures_to_sofia_output']

import os, sys
import shutil
import numpy as np
import logging
import warnings

from astropy.io import fits
from astropy.wcs import WCS
from astropy.table import Table, Column
from astropy.io.votable import parse_single_table
from astropy.coordinates import SkyCoord
from astroquery.skyview import SkyView
#from astroquery.utils import download_list_of_fitsfiles

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
from mpl_toolkits.axes_grid1 import make_axes_locatable
from matplotlib.offsetbox import AnchoredText
from matplotlib.patheffects import withStroke
 
import dstack as ds

#=== Globals ===
_HI_RESTFREQ = 1420405751.786 #[Hz]
_C = 299792.458 #[km/s] speed of light

#RCparams for plotting
matplotlib.rcParams['xtick.direction'] = 'in'
matplotlib.rcParams['ytick.direction'] = 'in'

matplotlib.rcParams['xtick.major.size'] = 9
matplotlib.rcParams['ytick.major.size'] = 9

matplotlib.rcParams['xtick.major.width'] = 3
matplotlib.rcParams['ytick.major.width'] = 3

matplotlib.rcParams['axes.linewidth'] = 2

plt.rcParams['xtick.labelsize']=16
plt.rcParams['ytick.labelsize']=16

#4 sampled colors from viridis
c0 = '#440154';#Purple
c1 = '#30678D';#Blue
c2 = '#35B778';#Greenish
c3 = '#FDE724';#Yellow

outlier_color = 'dimgrey'

#Select the colormap and set outliers
_CMAP = matplotlib.cm.viridis

_CMAP.set_bad(color=outlier_color)

#=== Setup logging ===
log = logging.getLogger(__name__)

#=== Disable fits warnings ===
#In fact this ignores all Warnings, so comment this line for debugging!
warnings.filterwarnings('ignore', category=Warning, append=True)

#=== Functions ===
#For improved 
def add_inner_title(ax, title, loc, size=None, **kwargs):
    """Create a fancy inner title for plots

    Parameters
    ==========
    ax: `matplotlib.axex`
        The axis which the inner title will be created

    title: str
        The title created

    loc: int
        Location. Can be verbose as well I think...

    size: dict, optional
        A dictionary containing the fontsize of the title
        eg. dict(size=18)
    
    Return
    ======
    at: artist
        The inner title artist that is added to the plot
    """
    if size is None:
        size = dict(size=plt.rcParams['legend.fontsize'])
    
    at = AnchoredText(title, loc=loc, prop=size,
                      pad=0., borderpad=0.5,
                      frameon=False, **kwargs)
    ax.add_artist(at)
    at.txt._text.set_path_effects([withStroke(foreground="w", linewidth=3)])
    
    return at

#= Source indexing
def get_source_files(source_ID, sofia_dir_path, name_base):
    """Return the full path of the files for a given source generated by
    SoFiA. The source ID is equivalent to the ID in the catalog generated
    by SoFiA.

    This code is minimalistic, and works on a 'standard' output of SoFiA
    see the code for the naming scheme I consider 'standard'.

    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !

    Return
    ======
    source_index: int
        The index of the row in the SoFiA database to which the ID belongs to (row index is ID-1 due to python)
    
    catalog_path: str
        Return the full path to the .xml table created by SoFiA
    
    cubelet_path_dict: dict
        A dictionary containing the full path for all the cubelets of the choosen source.
        The dict keys are self explanatory: 'chan', 'cube', 'mask', 'mom0', 'mom1', 'mom2'

    spectra_path: str
        Path to the spectra .txt file.
    """
    #The sources will have ID-1 row index number
    source_index = int(source_ID - 1)

    #Get the catalog path
    catalog_path = sofia_dir_path + name_base + 'cat.xml'

    #Get the list of cubelet images
    chan_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_chan.fits'
    cube_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_cube.fits'
    mask_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_mask.fits'
    mom0_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_mom0.fits'
    mom1_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_mom1.fits'
    mom2_cubelet_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_mom2.fits'
    
    cubelet_path_dict = {'chan' : chan_cubelet_path,
            'cube' : cube_cubelet_path,
            'mask' : mask_cubelet_path,
            'mom0' : mom0_cubelet_path,
            'mom1' : mom1_cubelet_path,
            'mom2' : mom2_cubelet_path}

    #Get spectra
    spectra_path = sofia_dir_path +  name_base + 'cubelets/' + name_base + str(source_ID) + '_spec.txt'

    return source_index, catalog_path, cubelet_path_dict, spectra_path

def get_N_sources(sofia_dir_path, name_base):
    """Simple script to get the number of sources from the SoFiA output catalog

    Parameters
    ==========
    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !

    Return
    ======
    N_sources: int
        Number of sources found by SoFiA. Equals to the number of rows in the dattabase created by SoFiA
    """
    #Get the catalog path
    catalog_path = sofia_dir_path + name_base + 'cat.xml'
    
    catalog = parse_single_table(catalog_path).to_table(use_names_over_ids=True)

    N_sources = np.shape(catalog)[0]
    
    return N_sources

#= Conversions & formulae
def get_z_from_freq(obs_freq):
    """ Convert observed frequency to (measured) redshift

    Parameters
    ==========
    obs_freq: float
        Observation (central) frequency in units of Hz !

    Return
    ======
    z: float
        Measured redshift
    """
    z = ( _HI_RESTFREQ / obs_freq ) - 1.

    return z

def get_velocity_from_freq(obs_freq, v_frame='optical'):
    """ Convert observed frequency to either optical or radio velocity

    Parameters
    ==========
    0obs_freq: float
        Observation frequency in [Hz]

    v_frame: str, optional
        Velocity frame to transform into. Can be `optical` or `radio`

    Return
    ======
    vel: float
        New velocity frame velocity values in [km/s]
    """
    if v_frame == 'optical':
        vel = _C * ((_HI_RESTFREQ / obs_freq ) - 1.)
    elif v_frame == 'radio':
        vel = _C * (1. - (obs_freq / _HI_RESTFREQ))
    else:
        raise ValueError('Not supported velocity frame!')
    
    return vel

def get_velocity_dispersion_from_freq(obs_freq_disp, obs_freq):
    """Convert the measured frequency dispersion values to velocity dispersion values

    Parameters
    ==========
    obs_freq_disp: float
        Observed frequency dispersion [Hz]

    0obs_freq: float
        Observation frequency in [Hz]

    Return
    ======
    vel_disp: float
        Velocity dispersion values in [km/s]
    """
    vel_disp = _C * (obs_freq_disp  / obs_freq )

    return vel_disp

def get_column_density(S, z, b_maj, b_min, scaling=1e-20):
    """Compute the column density by using eq. 74 from Meyer et al. 2017 

    It is needed to derive the moment0 maps.

    Parameters
    ==========
    S: float
        Measured absolute flux [Jy Hz]

    z: float
        Measured redshift of the source (use central frequency)

    b_maj: float
        Angular major axis of the beam [arcsec]
    
    b_min: float
        Angular minor axis of the beam [arcsec]

    scaling: float, optional
        A scaling factor that is used to convert the column density to a more readable unit.
        By default the unit is N atoms / cm^2, however it s more practical to have the
        units in terms of 10^(20) atoms / cm^2 for example. This can be acheved by the scaling factor

    Return
    ======
    N_HI: float
        Column density
    """
    N_HI = 2.33 * 1e+20 * np.power((1 + z),4) * ( S / (b_maj * b_min) ) * scaling

    return N_HI

def get_column_density_sensitivity(S_rms, z, b_maj, b_min, dnu, sigma_S=1, scaling=1e-20):
    """Compute the column density sensitivity by using eq. 135 from Meyer et al. 2017 

    It is needed to derive a moasking of the low SNR regions in the  moment0 maps.

    Parameters
    ==========
    S_rms: float
        Measured RMS around the source [Jy Hz]

    z: float
        Measured redshift of the source (use central frequency)

    b_maj: float
        Angular major axis of the beam [arcsec]
    
    b_min: float
        Angular minor axis of the beam [arcsec]

    dnu: float
        The frequency width of interest [Hz]

    sigma_S: float, optional
        What sensiticity level (sigma) we want to compute. One by default gives the noise floor,
        and e.g. 3 gives the 3sigma sensitivity level.

    scaling: float, optional
        A scaling factor that is used to convert the column density to a more readable unit.
        By default the unit is N atoms / cm^2, however it s more practical to have the
        units in terms of 10^(20) atoms / cm^2 for example. This can be acheved by the scaling factor


    Return
    ======
    N_HI_sensitivity: float
        Column density sensitivity in [N particles / cm^2]
    """
    S_sensitivity = S_rms * dnu * sigma_S

    N_HI_sensitivity = get_column_density(S_sensitivity, z, b_maj, b_min, scaling)
 
    return N_HI_sensitivity

#= Sofia catalog
def get_freq_and_redshift_from_catalog(catalog_path, source_index, rest_frame='frequency'):
    """ Extract the central (?) frequency and corresponding redshift from 
    the SFiA catalog (VO-table in xml format). Works on a given source defined by
    the source index, which is the row index (!) of the source not the catalog index.

    Note, that these should be identical though.

    Parameters
    ==========
    catalog_path: str
        Full path and file name of the SoFiA catalog

    source_index: int
        The row index of the source in the catalog.

    rest_frame: str, optional
        The rest frame used. Currently only 'frequency' frame supported. 

    Return
    ======
    freq: str
        Central frequency in [Hz]
    z: str
        Measured redshift
    """

    assert rest_frame == 'frequency', 'Currently only the frequency rest frame supported!'
  
    catalog = parse_single_table(catalog_path).to_table(use_names_over_ids=True)

    freq = catalog['freq'][source_index]
    z = get_z_from_freq(catalog['freq'][source_index])

    return freq, z

def get_RMS_from_catalog(catalog_path, source_index, rest_frame='frequency'):
    """Get the RMS value measured by SoFiA for the given source.

    Parameters
    ==========
    catalog_path: str
        Full path and file name of the SoFiA catalog

    source_index: int
        The row index of the source in the catalog.

    rest_frame: str, optional
        The rest frame used. Currently only 'frequency' frame supported. 

    Return
    ======
    rms: float
        Measured RMS
    """
    assert rest_frame == 'frequency', 'Currently only the frequency rest frame supported!'
  
    catalog = parse_single_table(catalog_path).to_table(use_names_over_ids=True)

    rms = catalog['rms'][source_index]
 
    return rms

#= Fits
def fget_wcs(fitsfile_path):
    """Get the World coordinate system (wcs) from the fits header for plotting.
    
    Parameters
    ==========
    fitsfile_path: str
        The input fits path

    Return
    ======
    wcs: `astropy.wcs.wcs.WCS`
        Image coordinates in WCS format
    """
    hdu = fits.getheader(fitsfile_path)
    wcs = WCS(hdu).celestial #RA Dec format
    
    return wcs

def fget_beam(fitsfile_path):
    """Get synthesised beam parameters from the
    input fits header

    Apparently the Sofia output fits have no beam information
    in their header.

    In fact some .fits I had to use SoFiA on had no beam info
    in the header, or at least the BMAJ, BMIN, BPA were not defined
    in the header. And so, I am not using this function.

    Parameters
    ==========
    fitsfile_path: str
        The input fits path

    Return
    ======
    b_maj: float
        Angular major axis of the beam [arcsec]
    
    b_min: float
        Angular minor axis of the beam [arcsec]

    b_pa: float
        Position angle of the beam [deg]
    """
    b_maj = fits.getheader(fitsfile_path)['BMAJ'] * 3600     # [arcsec]
    b_min = fits.getheader(fitsfile_path)['BMIN'] * 3600     # [arcsec]
    b_pa = fits.getheader(fitsfile_path)['BPA']              # [deg]
    
    return b_maj, b_min, b_pa

def fget_channel_width(fitsfile_path):
    """Get the channel width from the fits header

    Parameters
    ==========
    fitsfile_path: str
        The input fits path

    Return
    ======
    dnu: float
        The channel width in [Hz]
    """
    dnu = fits.getheader(fitsfile_path)['CDELT3'] #[Hz]
    
    return dnu

#= Get optical image
def get_optical_image(catalog_path, source_index, survey='DSS2 Red', N_optical_pixels=600, temp_fits_path=os.getcwd()):
    """ Download optical image cutsouts of sources from SkyVeiw via astroquery
    The optical image is by default from the 2nd Digitised sky survey (DSS2)
    red band: https://skyview.gsfc.nasa.gov/current/cgi/moreinfo.pl?survey=DSS2%20Red

    The resolution of the survey is 3", but the pixelsize is 1"

    However, some coordinates are not working and astroquery returns an empty list then.

    Thus a list of backup surveys are in place in the following order:
    DSS1 Red, DSS2 Blue, DSS1 Blue

    These surveys have different setup, so the background image nixel sizes are scaled accordingly.
    The scaling goes as the following:

    - DSS1 Red: /1.7 (https://skyview.gsfc.nasa.gov/current/cgi/moreinfo.pl?survey=DSS1%20Red)
    - DSS2 Blue: /1. (Experience, but this code is mainly for DINGO that targets the southern sky, so should be /1.7 ...) 
                    (https://skyview.gsfc.nasa.gov/current/cgi/moreinfo.pl?survey=DSS2%20Blue)
    - DSS1 Blue: /1.7 (https://skyview.gsfc.nasa.gov/current/cgi/moreinfo.pl?survey=DSS1%20Blue)

    As a back-up plan the near-IR image (DSS2 IR) is queried:
    https://skyview.gsfc.nasa.gov/current/cgi/moreinfo.pl?survey=DSS2%20IR

    As a last resort, the code creates an empty fits file positioned at the source and using pixel
    size of 1 arcsecond. This is a quick and dirty solution. The file is temprorary.

    If a different survey is given, the DSS survey queried as a backup.

    This function works with these parameters as default.

    The function creates NxN square stamp images, but the `N_pixel` variable can be changed 
    to create non-square images.

    Parameters
    ==========
    catalog_path: str
        Full path and file name of the SoFiA catalog

    source_index: int
        The index of the source in the catalog. (row index)

    survey: str, optional
        The name of the survey. `DSS2 Red` by default, but see the available list here: https://astroquery.readthedocs.io/en/latest/skyview/skyview.html

    N_optical_pixels: int, optional
        Number of pixels. The DSS2 Red pixel size is 1" thus for the default settings, this is the image siize in arcseconds. 
   
    temp_fits_path: str, optional
        Full path and file name to a fits file wich will be created in case no online data can be retrieved. This is a temprorary file and will be deleted
        This is the working directory by default.

    Return
    ======
    optical_fits_first_element: `PrimaryHDU`
        First element of the first element of the `astropy.io.fits.hdu.hdulist.HDUList` 
        returned form the `SkyView.get_images` method.

    survey_used: str
        The name of the survey used so it can be added to the images in case sources have different survey backgrounds
    """
    catalog = parse_single_table(catalog_path).to_table(use_names_over_ids=True)

    #Get the optical image centre from the SoFiA RA, Dec coordinates of the selected source
    ra = catalog['ra'][source_index]
    dec = catalog['dec'][source_index]
    pos = SkyCoord(ra=ra, dec=dec, unit='deg',equinox='J2000')

    # get (download) the image and select the first elemnt of the list (only one elemnt should be in the list returned)
    # Sometimes astroquery returns an empty array and I don't know why... (the skycoords are valid in these cases)
    def try_skyview_image(pos, survey, N_optical_pixels):
        """Simple function to fetch the optical background image from the respective
        database using `SkyView`
        """
        try:
            optical_fits_list = SkyView.get_images(position=pos, survey=survey, projection='Sin', pixels=N_optical_pixels)
        except:
            optical_fits_list = []

        return optical_fits_list

    log.info('Try to get {0:s} background image...'.format(survey))
    optical_fits_list = try_skyview_image(pos,survey,N_optical_pixels)
    
    if optical_fits_list == [] and survey != 'DSS2 Red':
        survey = 'DSS2 Red'
        log.info('Try to get DSS2 Red background image...')
        optical_fits_list = try_skyview_image(pos,survey,N_optical_pixels)
    
    if optical_fits_list == []:
        survey = 'DSS1 Red'
        log.info('Try to get DSS1 Red background image...')
        optical_fits_list = try_skyview_image(pos,survey,int(N_optical_pixels / 1.7))
        
    if optical_fits_list == []:
        survey = 'DSS2 Blue'
        log.info('Try to get DSS2 Blue background image...')
        optical_fits_list = try_skyview_image(pos,survey,N_optical_pixels)

    if optical_fits_list == []:
        survey = 'DSS1 Blue'
        log.info('Try to get DSS1 Blue background image...')
        optical_fits_list = try_skyview_image(pos,survey,int(N_optical_pixels / 1.7))

    if optical_fits_list == []:
        survey = 'DSS2 IR'
        log.info('Try to get DSS2 IR background image...')
        optical_fits_list = try_skyview_image(pos,survey,N_optical_pixels)
    
    if optical_fits_list != []:
        optical_fits = optical_fits_list[0]
        log.info('... querying done! Survey used: {0:s}'.format(survey))
    
    else:
        log.info('Failed to retrieve DSS images, creating balnk sky image...')
        #Create an empty fits file read in and delete it
        data_array = np.zeros((N_optical_pixels,N_optical_pixels))

        #Create the WCS
        w = WCS(naxis=2)
        # The negation in the longitude is needed by definition of RA, DEC
        w.wcs.cdelt = [-1 / 3600, 1 / 3600] #pixels in arcseconds
        w.wcs.crpix = [N_optical_pixels // 2 + 1, N_optical_pixels // 2 + 1]
        w.wcs.ctype = ["RA---SIN", "DEC--SIN"]
        w.wcs.crval = [pos.ra.deg, pos.dec.deg]
        w.naxis = 2
        w.wcs.radesys = 'ICRS'
        w.wcs.equinox = 2000.0

        #Create file and read in and the nelete it....
        #Remove file if exists
        if os.path.exists(temp_fits_path):
            os.remove(temp_fits_path)
        
        fits.writeto(filename=temp_fits_path, data=data_array, header=w.to_header(), 
                checksum=True, output_verify='ignore', overwrite=False)
        
        optical_fits = fits.open(temp_fits_path)
        
        #Remove for good
        os.remove(temp_fits_path)

        survey = 'None'

        log.info('... done! using empty sky')
    
    optical_fits_first_element = optical_fits[0]

    return optical_fits_first_element, survey

#= Create data cube functions for plotting
def get_optical_image_ndarray(source_ID, sofia_dir_path, name_base, N_optical_pixels=600):
    """Return the background optical image as a numpy array. It is an useful modularisation for ploting
    Furthermore, this can be imported to external code for more complex analysis.

    The optical image uses the current default settings, so more work needs to be done in this
    bit of function to be able to specify non-default background image using this code.

    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !

    N_optical_pixels: int, optional
         Number of pixels of the background image. Image size in arcseconds if the backfround is `DSS2 Red` (default)

    Return
    ======
    optical_image: `numpy.ndarray`
        The numpy array of the optical image yield by astroquery

    optical_im_wcs: `astropy.wcs.wcs.WCS`
        The WCS of the optical image
    """
    source_index, catalog_path, cubelet_path_dict, spectra_path = get_source_files(source_ID, sofia_dir_path, name_base)
    
    #Get optical image and coordinate system
    optical_im_fits_hdu, survey_used = get_optical_image(catalog_path, source_index, N_optical_pixels=N_optical_pixels)

    optical_im = optical_im_fits_hdu.data
    optical_im_wcs = WCS(optical_im_fits_hdu.header)

    return optical_im, optical_im_wcs, survey_used

def get_momN_ndarray(moment, source_ID, sofia_dir_path, name_base, masking=True, mask_sigma=3, b_maj=30, b_min=30):
    """Return the mom map defined by the arguments as a numpy array. It is an useful modularisation for ploting
    Furthermore, this can be imported to external code for more complex analysis.

    The masking only works for moment 1 and 2 maps.

    The function always returns three variables, however it only makes sense for mom0 maps.

    The third variable returned is a `None` for the mom1 an mom2 maps.
    Except if the masking is set to True, because then the column density sensitivity limit also returned

    For the moment0 maps the units are automatically converted to units of 10^20 particles / cm^2 !

    Parameters
    ==========
    moment: int
        The moment map that ndarray is returned (0,1 or 2) 
    
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !

    masking: bool, optional
        If True, pixel values below a certain sensitivity threshold will be masked out.

    mask_sigma: int, optional
        The masking threshold value. The masking is performed based on the moment0 map.
        The threshold is given in terms of column density sensitivity values (similarly to contour lines)

    b_maj: float, optional
        Angular major axis of the beam [arcsec]
    
    b_min: float, optional
        Angular minor axis of the beam [arcsec]

    Return
    ======
    col_den_map: `numpy.ndarray`
        The numpy array of the mom0 map, i.e. the column density values

    velocity_map: `numpy.ndarray`
        The numpy array of the mom1 map, i.e. the velocity field values

    velocity_dispersion_map: `numpy.ndarray`
        The numpy array of the mom1 map, i.e. the velocity dispersion values

    mom_wcs: `astropy.wcs.wcs.WCS`
        The WCS of the mom map

    col_den_sen_lim: float
        The column density sensitivity limit i.e. 1 sigma column density sensitivity.
   """
    source_index, catalog_path, cubelet_path_dict, spectra_path = get_source_files(source_ID, sofia_dir_path, name_base)

    #Get WCS (all mom ma have the same wcs)
    mom_wcs = fget_wcs(cubelet_path_dict['mom0'])

    if moment == 0 or masking == True:
        #Source parameters from catalog and cubelet
        freq, z = get_freq_and_redshift_from_catalog(catalog_path,source_index)
        dnu = fget_channel_width(cubelet_path_dict['cube'])
        rms = get_RMS_from_catalog(catalog_path,source_index)

        #Get moment0 (column density) map sensitivity and wcs 
        mom0_map = fits.getdata(cubelet_path_dict['mom0'])
        col_den_map = get_column_density(mom0_map, z, b_maj, b_min)
        col_den_sen_lim = get_column_density_sensitivity(rms, z, b_maj, b_min, dnu, 1)
 
        #Mask out the pixels with 0 values
        mask = (col_den_map == 0.)
        col_den_map = np.ma.array(col_den_map, mask=mask)

        if moment == 0:
            return col_den_map, mom_wcs, col_den_sen_lim

    if moment == 1:
        mom1_map = fits.getdata(cubelet_path_dict['mom1'])
        velocity_map = get_velocity_from_freq(mom1_map)

        # Mask out low column density data (< `mask_sigma' sigma)
        if masking:
            mask = (col_den_map <= col_den_sen_lim * mask_sigma)
            velocity_map = np.ma.array(velocity_map, mask=mask)
    
            return velocity_map, mom_wcs, col_den_sen_lim

        else:
            return velocity_map, mom_wcs, None

    elif moment == 2:
        freq, z = get_freq_and_redshift_from_catalog(catalog_path,source_index)
        mom2_map = fits.getdata(cubelet_path_dict['mom2'])
        velocity_dispersion_map = get_velocity_dispersion_from_freq(mom2_map, freq)

        # Mask out low column density data (< `mask_sigma' sigma)
        if masking:
            mask = (col_den_map <= col_den_sen_lim * mask_sigma)
            velocity_dispersion_map = np.ma.array(velocity_dispersion_map, mask=mask)
    
            return velocity_dispersion_map, mom_wcs, col_den_sen_lim

        else:
            return velocity_dispersion_map, mom_wcs, None

    else:
        raise ValueError('Invalid moment value was given. Only moment 0,1 and 2 maps are supported!')

def get_spectra_array(source_ID, sofia_dir_path, name_base, v_frame='optical', beam_correction=True, b_maj_px=5, b_min_px=5):
    """Returns two arrays: Integrated Flux [Jy] and velocity [km/s] (optical by default) for spectral plots.
    Again, modularisation is the idea behind this function. However, there are some caveats with the SoFiA output and
    the ways the spectra is created.

    When the grids are created the pixel units are changed to [Jy/pixel]. However, the output images have
    the real unit of [Jy/beam]! This is beacuse the grid unis is correctly [Jy/pixel], but the conversion
    does not happen (of the unit) when the grids are FFTd to the image plane.

    Therefore, the SoFiA output spectra has the unit [Jy/pixel], but it is actually [Jy/beam],
    and so the beam correction needs to be done. For the correction, we need to manually
    divide by the beam area which, for Gaussian beams, will be

                   :math:pi * a * b / (4 * ln(2)):

    where a and b are the major and minor axis of the beam in units of pixels.

    This correction can be disabled, but currently is the default.

    The velocity axis can be frequency, optical or radio velocity.

    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !
    
    v_frame: str, optional
        The velocity frame. Can be 'frequency', 'optical' or 'radio'
    
    beam_correction: bool, optional
        If True, the flux values are corrected for the synthesised beam

    b_maj_px: float, optional
        The major axis of the beam in pixels

    b_min_px: float, optional
        The minor axis of the beam in pixels

    Return
    ======
    flux_array: `numpy.ndarray`
        The measured integrated flux values in [Jy]

    velocity_array: `numpy.ndarray`
        The corresponding velocity valuse in the given frame
    """
    source_index, catalog_path, cubelet_path_dict, spectra_path = get_source_files(source_ID, sofia_dir_path, name_base)

    sofia_spectra = np.genfromtxt(spectra_path)

    #Get the corresponding arrays and transform them to the given frame
    flux_array= sofia_spectra[:,2]
    
    if beam_correction:
        flux_array /= np.pi * b_maj_px * b_min_px / (4 * np.log(2) )

    freq_array = sofia_spectra[:,1]

    if v_frame == 'frequency':
        return flux_array, freq_array

    else:
        velocity_array = get_velocity_from_freq(freq_array, v_frame=v_frame)
        return flux_array, velocity_array
       
#= Plot functions
def plot_optical_background_with_mom0_conturs(source_ID, sofia_dir_path, name_base, output_fname, contour_levels=[3,5,7,9,11], N_optical_pixels=600, b_maj=30, b_min=30, b_pa=0, **kwargs):
    """Create a map with the `DSS2 Red` image in the background and the mom0 map fitted contours in the foreground.

    Simple function for quick analysis of a single source.

    Advised to create .png output, which can be integrated into `Radiopadre` analysis notebooks.

    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !
   
    output_fname: str
        The full path and filename for the output image created.
 
    contour_levels: list, optional
        List of contour levels to be drawn. The levels are defined in terms of column-density sensitivity

    N_optical_pixels: int, optional
        Number of pixels of the background image. Image size in arcseconds if the backfround is `DSS2 Red` (default)
    
    b_maj: float, optional
        Angular major axis of the beam [arcsec]
    
    b_min: float, optional
        Angular minor axis of the beam [arcsec]

    b_pa: float, optional
        Angle of the beam [deg]

    Return
    ======
    output_image: file
        The image created
    """
    log.info('Create optical background and mom0 contours...')
    #Get data arrays
    mom = 0
    col_den_map, mom0_wcs, col_den_sen_lim = get_momN_ndarray(mom, source_ID, sofia_dir_path, name_base, b_maj=b_maj, b_min=b_min)
    optical_im, optical_im_wcs, survey_used = get_optical_image_ndarray(source_ID, sofia_dir_path, name_base, N_optical_pixels=N_optical_pixels)
    
    #Create plot
    fig = plt.figure(1, figsize=(12,12))
    ax = fig.add_subplot(111, projection=optical_im_wcs)

    ax.imshow(optical_im.data,origin='lower',cmap='Greys')
    ax.contour(col_den_map, levels=np.multiply(np.array(contour_levels),col_den_sen_lim),transform=ax.get_transform(mom0_wcs))

    ax.coords.grid(color='k', alpha=0.5, linestyle='dashed')
    ax.coords[0].set_major_formatter('hh:mm:ss')
    ax.coords[1].set_major_formatter('dd:mm')
    ax.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = optical_im_wcs.array_index_to_world(int(0.025 * N_optical_pixels), int(0.025 * N_optical_pixels)).ra.value
    beam_loc_dec = optical_im_wcs.array_index_to_world(int(0.025 * N_optical_pixels), int(0.025 * N_optical_pixels)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='black', ec='black', alpha=0.75, transform=ax.get_transform('fk5'))
    ax.add_patch(beam_ellip)

    #Add inner title
    t = add_inner_title(ax, survey_used + ' + mom0 contours', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    plt.savefig(output_fname,bbox_inches='tight')
    plt.close()

def plot_momN_map(moment, source_ID, sofia_dir_path, name_base, output_fname, masking=True, mask_sigma=3, contours=False, contour_levels=[3,5,7,9,11], b_maj=30, b_min=30, b_pa=0, **kwargs):
    """Create the mom map with optionally the fitted contours in the foreground and masking of low
    column density sensitivity pixels (mom1 and mom2 only).

    Simple function for quick analysis of a single source.

    Advised to create .png output, which can be integrated into `Radiopadre` analysis notebooks.

    Parameters
    ==========
    moment: int
        The moment map that ndarray is returned (0,1 or 2) 
 
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !
   
    output_fname: str
        The full path and filename for the output image created.
 
    masking: bool, optional
        If True, pixel values below a certain sensitivity threshold will be masked out.

    mask_sigma: int, optional
        The masking threshold value. The masking is performed based on the moment0 map.
        The threshold is given in terms of column density sensitivity values (similarly to contour lines)

    contours: bool, optional
        If True, the contours will be overlayed onto the mom0 image

    contour_levels: list, optional
        List of contour levels to be drawn. The levels are defined in terms of column-density sensitivity

    b_maj: float, optional
        Angular major axis of the beam [arcsec]
    
    b_min: float, optional
        Angular minor axis of the beam [arcsec]

    b_pa: float, optional
        Angle of the beam [deg]

    Return
    ======
    output_image: file
        The image created
    """
    log.info('Create mom{0:d} map...'.format(moment))
    #Get data arrays
    mom_map, mom_wcs, col_den_sen_lim = get_momN_ndarray(moment, source_ID, sofia_dir_path, name_base, masking, mask_sigma, b_maj=b_maj, b_min=b_min)

    #Set outlier values(0s) to inf
    mom_map[mom_map == 0. ] = np.inf

    #Create plot
    fig = plt.figure(1, figsize=(12,12))
    ax = fig.add_subplot(111, projection=mom_wcs)
 
    mom_fig = ax.imshow(mom_map, origin='lower', cmap=_CMAP)

    if contours:
        ax.contour(mom_map, levels=np.multiply(np.array(contour_levels),col_den_sen_lim),
                transform=ax.get_transform(mom_wcs), colors='white', alpha=0.5)

    #Colorbar settings
    cb = plt.colorbar(mom_fig, ax=ax, aspect=30, fraction=0.04975, pad=0)
    
    cb.ax.yaxis.get_offset_text().set_fontsize(18)
    cb.ax.tick_params(labelsize=18)
    cb.ax.tick_params(direction='in', length=6, width=2)

    if moment == 0:
        cb.ax.set_ylabel(r'N$_{HI}$ [10$^{20}$cm$^2$]', fontsize = 18)
    else:
        cb.ax.set_ylabel(r'v$_{opt}$ [km/s]', fontsize = 18)

    #Label settings
    ax.coords.grid(color='white', alpha=0.5, linestyle='dashed')
    ax.coords[0].set_major_formatter('hh:mm:ss')
    ax.coords[1].set_major_formatter('dd:mm')
    ax.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = mom_wcs.array_index_to_world(int(np.shape(mom_map)[0] * 0.05), int(np.shape(mom_map)[0] * 0.05)).ra.value
    beam_loc_dec = mom_wcs.array_index_to_world(int(np.shape(mom_map)[0] * 0.05), int(np.shape(mom_map)[0] * 0.05)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='white', ec='white', alpha=1., transform=ax.get_transform('fk5'))
    ax.add_patch(beam_ellip)

    #Add inner title
    if moment == 0:
        t = add_inner_title(ax, 'mom0 + contours', loc=2, size=dict(size=16))
    else:
        t = add_inner_title(ax, 'mom{0:d} map'.format(moment), loc=2, size=dict(size=16))

    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    plt.savefig(output_fname,bbox_inches='tight')
    plt.close()

def plot_spectra(source_ID, sofia_dir_path, name_base, output_fname, v_frame='optical', beam_correction=True, b_maj_px=5, b_min_px=5):
    """Plot the integrated spectra of the source.

    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !

    output_fname: str
        The full path and filename for the output image created.
    
    v_frame: str, optional
        The velocity frame. Can be 'frequency', 'optical' or 'radio'
    
    beam_correction: bool, optional
        If True, the flux values are corrected for the synthesised beam

    b_maj_px: float, optional
        The major axis of the beam in pixels

    b_min_px: float, optional
        The minor axis of the beam in pixels

    Return
    ======
    output_image: file
        The image created
    """
    log.info('Create spectra plot...')
    flux, velocity = get_spectra_array(source_ID, sofia_dir_path, name_base, v_frame, beam_correction, b_maj_px, b_min_px)

    #Create plot
    fig = plt.figure(1, figsize=(12,12))
    ax = fig.add_subplot(111)

    ax.step(velocity, flux, lw=3, c=c1)
    
    ax.set_xlabel(r'v$_{opt}$ (km/s)', fontsize=18)
    ax.set_ylabel('Flux density (Jy)', fontsize=18)
    ax.grid()

    #Add inner title
    t = add_inner_title(ax, 'Spectra', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    plt.savefig(output_fname,bbox_inches='tight')
    plt.close()

def source_analytics_plot(source_ID, sofia_dir_path, name_base, output_fname, masking=True, mask_sigma=3, contour_levels=[3,5,7,9,11], N_optical_pixels=600, b_maj=30, b_min=30, b_pa=0, v_frame='optical', beam_correction=True, b_maj_px=5, b_min_px=5):
    """Create all analytics plots on a fingle figure gor a given source. The plots created are:

        - mom0 contours on the optical background
        - mom0 map with contours
        - mom1 map
        - mom2 map
        - spectra

    This code is mostly copy-paste of the individual imaging functions, which is not a good practice...
    Also, this code have waaaay to many arguments...

    Nevertheless, this is the only code which should be run on all sources found by SoFiA.

    The code can be slow, as all cubelet arrays are read in multiple times due to modularisation.
    I am not sure how good of a solution this is, but makes the code more readable I think...

    Based on the functions above, it should be self-explanatory what exacty happening in this code.

    
    Parameters
    ==========
    source_ID: int
        The ID of the selected source. IDs are not pythonic; i.e. the first ID is 1.

    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !
   
    output_fname: str
        The full path and filename for the output image created.
 
    masking: bool, optional
        If True, pixel values below a certain sensitivity threshold will be masked out.

    mask_sigma: int, optional
        The masking threshold value. The masking is performed based on the moment0 map.
        The threshold is given in terms of column density sensitivity values (similarly to contour lines)

    contour_levels: list, optional
        List of contour levels to be drawn. The levels are defined in terms of column-density sensitivity

    N_optical_pixels: int, optional
        Number of pixels of the background image. Image size in arcseconds if the backfround is `DSS2 Red` (default)
    
    b_maj: float, optional
        Angular major axis of the beam [arcsec]
    
    b_min: float, optional
        Angular minor axis of the beam [arcsec]

    b_pa: float, optional
        Angle of the beam [deg]

    v_frame: str, optional
        The velocity frame. Can be 'frequency', 'optical' or 'radio'
    
    beam_correction: bool, optional
        If True, the flux values are corrected for the synthesised beam

    b_maj_px: float, optional
        The major axis of the beam in pixels

    b_min_px: float, optional
        The minor axis of the beam in pixels

    Return
    ======
    output_image: file
        The image created
    

    """
    log.info('Create summary image...')
    #Get the data arrays
    mom0_map, mom_wcs, col_den_sen_lim = get_momN_ndarray(moment=0, source_ID=source_ID, sofia_dir_path=sofia_dir_path, name_base=name_base, b_maj=b_maj, b_min=b_min)
    optical_im, optical_im_wcs, survey_used = get_optical_image_ndarray(source_ID=source_ID, sofia_dir_path=sofia_dir_path, name_base=name_base, N_optical_pixels=N_optical_pixels)

    mom1_map, mom_wcs, col_den_sen_lim = get_momN_ndarray(moment=1, source_ID=source_ID, sofia_dir_path=sofia_dir_path, name_base=name_base,
            masking=masking, mask_sigma=mask_sigma, b_maj=b_maj, b_min=b_min)

    mom2_map, mom_wcs, col_den_sen_lim = get_momN_ndarray(moment=2, source_ID=source_ID, sofia_dir_path=sofia_dir_path, name_base=name_base,
            masking=masking, mask_sigma=mask_sigma, b_maj=b_maj, b_min=b_min)

    flux, velocity = get_spectra_array(source_ID=source_ID, sofia_dir_path=sofia_dir_path, name_base=name_base,
            v_frame=v_frame, beam_correction=beam_correction, b_maj_px=b_maj_px, b_min_px=b_min_px)

    #Create the plot
    fig = plt.figure(1, figsize=(25,12))
    #Big spacing between plots, as the source cubelets can vary and the colorbars are not calculated into the subplot sizes...
    fig.subplots_adjust(left=0.15, right=0.8, top=0.9, bottom=0.1, wspace=0.5, hspace=0.25)

    fig.suptitle('Source no. {0:d}'.format(source_ID), fontsize=24)

    #mom0 conours with optical background
    ax0 = fig.add_subplot(231, projection=optical_im_wcs)

    ax0.imshow(optical_im.data,origin='lower',cmap='Greys')
    ax0.contour(mom0_map, levels=np.multiply(np.array(contour_levels),col_den_sen_lim),transform=ax0.get_transform(mom_wcs))

    ax0.coords.grid(color='k', alpha=0.5, linestyle='dashed')
    ax0.coords[0].set_major_formatter('hh:mm:ss')
    ax0.coords[1].set_major_formatter('dd:mm')
    ax0.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax0.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = optical_im_wcs.array_index_to_world(int(0.025 * N_optical_pixels), int(0.025 * N_optical_pixels)).ra.value
    beam_loc_dec = optical_im_wcs.array_index_to_world(int(0.025 * N_optical_pixels), int(0.025 * N_optical_pixels)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='black', ec='black', alpha=0.75, transform=ax0.get_transform('fk5'))
    ax0.add_patch(beam_ellip)

    #Add inner title
    t = add_inner_title(ax0, survey_used + ' + mom0 contours', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    #mom0 map
    ax1 = fig.add_subplot(232, projection=mom_wcs)
    
   
    mom0_fig = ax1.imshow(mom0_map, origin='lower', cmap=_CMAP)

    ax1.contour(mom0_map, levels=np.multiply(np.array(contour_levels),col_den_sen_lim),
            transform=ax1.get_transform(mom_wcs), colors='white', alpha=0.5)

    #Colorbar settings
    cb = fig.colorbar(mom0_fig, ax=ax1, orientation='vertical', aspect=30, fraction=0.04975, pad=0)
    
    cb.ax.yaxis.get_offset_text().set_fontsize(18)
    cb.ax.tick_params(labelsize=18)
    cb.ax.tick_params(direction='in', length=6, width=2)
    cb.ax.set_ylabel(r'N$_{HI}$ [10$^{20}$cm$^2$]', fontsize = 18)
    
    #Label settings
    ax1.coords.grid(color='white', alpha=0.5, linestyle='dashed')
    ax1.coords[0].set_major_formatter('hh:mm:ss')
    ax1.coords[1].set_major_formatter('dd:mm')
    ax1.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax1.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = mom_wcs.array_index_to_world(int(np.shape(mom0_map)[0] * 0.05), int(np.shape(mom0_map)[0] * 0.05)).ra.value
    beam_loc_dec = mom_wcs.array_index_to_world(int(np.shape(mom0_map)[0] * 0.05), int(np.shape(mom0_map)[0] * 0.05)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='white', ec='white', alpha=1., transform=ax1.get_transform('fk5'))
    ax1.add_patch(beam_ellip)

    #Add inner title
    t = add_inner_title(ax1, 'mom0 map + contours', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    #mom1 map
    ax2 = fig.add_subplot(234, projection=mom_wcs)
 
    mom1_fig = ax2.imshow(mom1_map, origin='lower', cmap=_CMAP)

    #Colorbar settings
    cb = fig.colorbar(mom1_fig, ax=ax2, aspect=30, fraction=0.04975, pad=0)
    
    cb.ax.yaxis.get_offset_text().set_fontsize(18)
    cb.ax.tick_params(labelsize=18)
    cb.ax.tick_params(direction='in', length=6, width=2)
    cb.ax.set_ylabel(r'v$_{opt}$ [km/s]', fontsize = 18)
    
    #Label settings
    ax2.coords.grid(color='white', alpha=0.5, linestyle='dashed')
    ax2.coords[0].set_major_formatter('hh:mm:ss')
    ax2.coords[1].set_major_formatter('dd:mm')
    ax2.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax2.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = mom_wcs.array_index_to_world(int(np.shape(mom1_map)[0] * 0.05), int(np.shape(mom1_map)[0] * 0.05)).ra.value
    beam_loc_dec = mom_wcs.array_index_to_world(int(np.shape(mom1_map)[0] * 0.05), int(np.shape(mom1_map)[0] * 0.05)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='white', ec='white', alpha=1., transform=ax2.get_transform('fk5'))
    ax2.add_patch(beam_ellip)

    #Add inner title
    t = add_inner_title(ax2, 'mom1 map', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    #mom2 map
    ax3 = fig.add_subplot(235, projection=mom_wcs)
 
    mom2_fig = ax3.imshow(mom2_map, origin='lower', cmap=_CMAP)

    #Colorbar settings
    cb = fig.colorbar(mom2_fig, ax=ax3, aspect=30, fraction=0.04975, pad=0)
    
    cb.ax.yaxis.get_offset_text().set_fontsize(18)
    cb.ax.tick_params(labelsize=18)
    cb.ax.tick_params(direction='in', length=6, width=2)
    cb.ax.set_ylabel(r'v$_{opt}$ [km/s]', fontsize = 18)
    
    #Label settings
    ax3.coords.grid(color='white', alpha=0.5, linestyle='dashed')
    ax3.coords[0].set_major_formatter('hh:mm:ss')
    ax3.coords[1].set_major_formatter('dd:mm')
    ax3.coords[0].set_axislabel('RA (J2000)', fontsize=16)
    ax3.coords[1].set_axislabel('Dec (J2000)', fontsize=16)

    #Add beam ellipse centre is defined as a fraction of the background image size
    beam_loc_ra = mom_wcs.array_index_to_world(int(np.shape(mom2_map)[0] * 0.05), int(np.shape(mom2_map)[0] * 0.05)).ra.value
    beam_loc_dec = mom_wcs.array_index_to_world(int(np.shape(mom2_map)[0] * 0.05), int(np.shape(mom2_map)[0] * 0.05)).dec.value

    beam_ellip = Ellipse((beam_loc_ra, beam_loc_dec), b_maj/3600, b_min/3600, b_pa, fc='white', ec='white', alpha=1., transform=ax3.get_transform('fk5'))
    ax3.add_patch(beam_ellip)

    #Add inner title
    t = add_inner_title(ax3, 'mom2 map', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    #Spectra plot
    ax4 = fig.add_subplot(233)

    ax4.step(velocity, flux, lw=3, c=c1)
    
    ax4.set_xlabel(r'v$_{opt}$ (km/s)', fontsize=18)
    ax4.set_ylabel('Flux density (Jy)', fontsize=18)
    ax4.grid()
    
    #Add inner title
    t = add_inner_title(ax4, 'Spectra', loc=2, size=dict(size=16))
    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)
   
    plt.savefig(output_fname,bbox_inches='tight')
    plt.close('all')

def create_complementary_figures_to_sofia_output(sofia_dir_path, name_base, masking=True, mask_sigma=3, contour_levels=[3,5,7,9,11], N_optical_pixels=600, b_maj=30, b_min=30, b_pa=0, v_frame='optical', beam_correction=True, b_maj_px=5, b_min_px=5):
    """The top-level function of this module. It creates a directory within the SoFiA output directory and
    generate the following plots for each source in that directory:
        
        - summary plot
   
    Into a sub-folder for each source:

        - mom0 contours on the optical background
        - mom0 map with contours
        - mom1 map
        - mom2 map
        - spectra

    I will create an application for this task, which I can integrate into the pipeline, so the pipeline
    can automatically generate these plots, which are complementary to the SoFiA output.

    These images can be rendered into a `Radiopadre` notebook for quick look at the data.
    Or this function can be called within the notebook...

    For the detailed description and details see each individual function called.

    The naming scheme of the individual images follows the SoFiA cubelet naming scheme.
    The images are created under the folder `name_base`_ds_images/ folder
    The individual source images are created unde the source_ID/ folders

    Parameters
    ==========
    sofia_dir_path: str
        Full path to the directory where the output of SoFiA saved/generated. Has to end with a slash (/)!

    name_base: str
      The `output.filename` variable defined in the SoFiA template .par. Basically the base of all file names.
      However, it has to end with a lower dash (?): _ !
   
    masking: bool, optional
        If True, pixel values below a certain sensitivity threshold will be masked out.

    mask_sigma: int, optional
        The masking threshold value. The masking is performed based on the moment0 map.
        The threshold is given in terms of column density sensitivity values (similarly to contour lines)

    contour_levels: list, optional
        List of contour levels to be drawn. The levels are defined in terms of column-density sensitivity

    N_optical_pixels: int, optional
        Number of pixels of the background image. Image size in arcseconds if the background is `DSS2 Red` (default)
     
    b_maj: float, optional
        Angular major axis of the beam [arcsec]
    
    b_min: float, optional
        Angular minor axis of the beam [arcsec]

    b_pa: float, optional
        Angle of the beam [deg]

    v_frame: str, optional
        The velocity frame. Can be 'frequency', 'optical' or 'radio'
    
    beam_correction: bool, optional
        If True, the flux values are corrected for the synthesised beam

    b_maj_px: float, optional
        The major axis of the beam in pixels

    b_min_px: float, optional
        The minor axis of the beam in pixels

    Return
    ======
    output_images: files
        The images created
    """
    #Create the image directory if not existing
    working_dir = sofia_dir_path + name_base + 'ds_images/'
    
    if not os.path.exists(working_dir):
        os.mkdir(working_dir)

    log.info('\nCreating images fro SoFiA output at: {0:s}'.format(working_dir))

    #Loop through sources
    N_sources = get_N_sources(sofia_dir_path = sofia_dir_path, name_base = name_base)

    for ID in range(1, N_sources + 1):
        log.info('\nCreating images for source no. {0:d}\n'.format(ID))

        #Summary image
        source_analytics_plot(source_ID = ID, 
            sofia_dir_path = sofia_dir_path,
            name_base = name_base,
            N_optical_pixels = N_optical_pixels,
            masking = masking,
            mask_sigma = mask_sigma,
            contour_levels = contour_levels,
            b_maj = b_maj,
            b_min = b_min,
            b_pa = b_pa,
            beam_correction = beam_correction, 
            b_maj_px = b_maj_px, 
            b_min_px = b_min_px,
            v_frame = v_frame,
            output_fname = working_dir + name_base + '{0:d}_summary.png'.format(ID))
        
        #Create sub-directory and the individual images inside
        source_working_dir = working_dir + 'source_{0:d}/'.format(ID)
    
        if not os.path.exists(source_working_dir):
            os.mkdir(source_working_dir)
        
        #mom0 with optical background
        plot_optical_background_with_mom0_conturs(source_ID = ID, 
            sofia_dir_path = sofia_dir_path,
            name_base = name_base,
            contour_levels = contour_levels,
            N_optical_pixels = N_optical_pixels,
            b_maj = b_maj,
            b_min = b_min,
            b_pa = b_pa,
            output_fname = source_working_dir + name_base + '{0:d}_optical.png'.format(ID)) 

        #mom maps
        contour_list = [True, False, False]
        
        for mom, cont_enable in zip(range(0,3), contour_list): 
            plot_momN_map(moment = mom, 
                    source_ID = ID,
                    sofia_dir_path = sofia_dir_path,
                    name_base = name_base,
                    masking = masking,
                    mask_sigma = mask_sigma,
                    contours = cont_enable,
                    contour_levels = contour_levels,
                    b_maj = b_maj,
                    b_min = b_min,
                    b_pa = b_pa,
                    output_fname = source_working_dir + name_base + '{0:d}_mom{1:d}.png'.format(ID,mom))

        #spectra
        plot_spectra(source_ID = ID,
                sofia_dir_path = sofia_dir_path,
                name_base = name_base,
                v_frame = v_frame,
                beam_correction = beam_correction,
                b_maj_px = b_maj_px,
                b_min_px = b_min_px,
                output_fname = source_working_dir + name_base + '{0:d}_spec.png'.format(ID))

#=== MAIN ===
if __name__ == "__main__":
    #pass
    log.setLevel(logging.INFO)
    log.addHandler(logging.StreamHandler(sys.stdout))

    #Chiles example

    create_complementary_figures_to_sofia_output(
        sofia_dir_path = '/home/krozgonyi/Desktop/chiles_example/runSoFiA/',
        name_base = 'chiles_example_',
        N_optical_pixels = 100,
        masking = True,
        mask_sigma = 3,
        contour_levels = [3,5,7,9,11],
        b_maj = 7,
        b_min = 5,
        b_pa = -45,
        beam_correction = True, 
        b_maj_px = 4, 
        b_min_px = 4,
        v_frame = 'optical')

    exit()



    #2km baselines
    stacking_method_sofia_output_list = ['/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/stacked_grids/',
        '/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/stacked_images/',
        '/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/co_added_visibilities/',
        '/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/conventional_imaging/']

    for stacking_sofia_output in stacking_method_sofia_output_list:
        create_complementary_figures_to_sofia_output(
            sofia_dir_path = stacking_sofia_output,
            name_base = 'beam17_all_',
            N_optical_pixels = 900,
            masking = True,
            mask_sigma = 3,
            contour_levels = [3,5,7,9,11],
            b_maj = 30,
            b_min = 30,
            b_pa = 0,
            beam_correction = True, 
            b_maj_px = 5, 
            b_min_px = 5,
            v_frame = 'optical')

    #6 km baselines
    high_res_stacking_method_sofia_output_list = ['/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/high_resolution/stacked_grids/',
        '/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/high_resolution/stacked_images/',
        '/home/krozgonyi/Desktop/quick_and_dirty_sofia_outputs/high_resolution/co_added_visibilities/']

    for stacking_sofia_output in high_res_stacking_method_sofia_output_list:
        create_complementary_figures_to_sofia_output(
            sofia_dir_path = stacking_sofia_output,
            name_base = 'beam17_all_',
            N_optical_pixels = 900,
            masking = True,
            mask_sigma = 3,
            contour_levels = [3,5,7,9,11],
            b_maj = 12,
            b_min = 12,
            b_pa = 0,
            beam_correction = True, 
            b_maj_px = 6, 
            b_min_px = 6,
            v_frame = 'optical')

    exit()

