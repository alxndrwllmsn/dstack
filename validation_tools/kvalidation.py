"""These functions are used to compare the kynematics of the sources foud 
by SoFiA in different pipeline setups and modelled in 3DBarolo.

Therefore, this code is really similar to `sdiagnostics`, but work son the 3DBarolo
output of a source to compare kinematics models.

The code compare rotation curves, p-v diagrams and density profiles.

We used these diagnostics jointly with the `sdiagnostics` code to validate the
grid stacking pipeline.
"""
#=== Imports ===
import os, sys
import shutil
import numpy as np
import logging
import warnings
import random

import copy

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from matplotlib.offsetbox import AnchoredText
from matplotlib.patheffects import withStroke

from astropy.io import fits

import cmocean

import dstack as ds

#=== Setup logging ===
log = logging.getLogger(__name__)

#=== Globals ===
#RCparams for plotting
matplotlib.rcParams['xtick.direction'] = 'in'
matplotlib.rcParams['ytick.direction'] = 'in'

matplotlib.rcParams['xtick.major.size'] = 9
matplotlib.rcParams['ytick.major.size'] = 9

matplotlib.rcParams['xtick.major.width'] = 3
matplotlib.rcParams['ytick.major.width'] = 3

matplotlib.rcParams['axes.linewidth'] = 2

plt.rcParams['xtick.labelsize']=16
plt.rcParams['ytick.labelsize']=16

#4 sampled colors from viridis
c0 = '#440154';#Purple
c1 = '#30678D';#Blue
c2 = '#35B778';#Greenish
c3 = '#FDE724';#Yellow

outlier_color = 'dimgrey'

#Select the colormap and set outliers
_CMAP = matplotlib.cm.viridis
_CMAP.set_bad(color=outlier_color)

#Set the secondary colormap
#_DIV_CMAP = cmocean.cm.oxy
#_CMAP2 = matplotlib.cm.plasma
#_CMAP2 = matplotlib.cm.viridis
_CMAP2 = matplotlib.cm.cividis
#_CMAP2 = cmocean.cm.delta
#_CMAP2 = cmocean.cm.curl
#_CMAP2 = cmocean.cm.balance
_CMAP2.set_bad(color=outlier_color)

#Set diverging colormap default
#_DIV_CMAP = cmocean.cm.balance
_DIV_CMAP = cmocean.cm.delta
_DIV_CMAP.set_bad(color=outlier_color)

#=== Disable fits warnings ===
#In fact this ignores all Warnings, so comment this line for debugging!
warnings.filterwarnings('ignore', category=Warning, append=True)

#=== Functions ===
def initialise_argument_list(required_list_length,argument_list):
    """Funtion to recursively append the argument lists if needed.

    Always append with the last element.

    This function is copied from `svalidation`, it should rather be imported
    from somwhere! TO DO: put this to sdiagnostics maybe.

    Parameters
    ==========
    required_list_length: int
        Goal lenght to append

    argument_list: list
        List to append if needed

    Return
    ======
    argument_list: list
        Appended list

    """
    while len(argument_list) != required_list_length:
        argument_list.append(argument_list[-1])
        
        #Lazy error handeling (does not matter if input list is longer)
        if len(argument_list) > required_list_length:
            warnings.warn('Argument list {} is longer than the number of sources provided!'.format(argument_list))
            return argument_list

    return argument_list

def plot_profile_curves(rot_dir_list,
                    profile_file_name_list,
                    output_fname,
                    profile='rotation',
                    ring_crop=2,
                    inner_ring_crop=0,
                    label_list=['?'],
                    color_list=[None]):
    """This is a simple function to plot different models fit on different deep
    imaging methods. The main curves this function can produce:

    - rotation curves
    - dispersion curves
    - density profiles

    NOTE, that 3DBarolo generates the fit and this code just overplot the output of
    differet runs!

    Parameters
    ==========

    rot_dir_list: list of str
        The full path of each 3DBarolo output which under the fit text files live.

    profile_file_name_list: lost of strings
        The name of the profile file generated by 3DBarolo. As several fit cycles are possible,
        this can be te first of the final cycle. Also, the density profiles are
        outputted to a different file than the rotation curves. This si the file name
        that will be used for generating the plots!

    output_fname: str
        Name and full path of the images created.

    profile: str, optional
        The type of the profile plot generated. Currently, the following profiles
        are supported: rotation, dispersion and density

    ring_crop: int, optional
        Number of the tilted ring model rings to exclude from the data, since the
        outter rings are fitted to the noisy data. The number of rings from the
        are excluded from the plots. If negative, rings starting from the inside
        are excluded and so this parameter has to be >= 0!

    inner_ring_crop: int, optional
        Number of rings from the inside, not included in the plots. Useful for the
        6km baseline modeling, as the innermost rings(s) can yield weird values...

    label list, list of strings, optional
        A string for each 3DBarolo output, that is displayed as a legend on the plot

    color_list: list of strings, optional
        The color for each 3DBarolo output on the plot

    Return
    ======
    output_image: file
        The image created
 
    """
    #Check the available profiles
    if profile not in ['rotation', 'dispersion', 'density']:
        raise TypeError('Invalid profile image requested!')

    N_sources = len(rot_dir_list)

    profile_file_name_list = initialise_argument_list(N_sources, profile_file_name_list)
    label_list = initialise_argument_list(N_sources, label_list)

    #Generate random colors if needed
    color_list = initialise_argument_list(N_sources, color_list)
    for i in range(0,N_sources):
        if color_list[i] == None:
            color_list[i] = "#{:06x}".format(random.randint(0, 0xFFFFFF)) #Generate random HEX color
    

    #ring_crop = 2
 
    #Create plot
    fig = plt.figure(1, figsize=(8,5))
    ax = fig.add_subplot(111)

    lines = []

    for i in range(0,N_sources):
        profilefit_file_path = rot_dir_list[i] + profile_file_name_list[i]


        if profile in ['rotation', 'dispersion']:
            #The rotation curve
            rad, vrot, srot = np.genfromtxt(profilefit_file_path, skip_header=1,
                                    usecols=(1,2,3), unpack=True) 

            #Crop the last N ringfit
            rad = rad[inner_ring_crop:-ring_crop]
            vrot = vrot[inner_ring_crop:-ring_crop]
            srot = srot[inner_ring_crop:-ring_crop]       

            #compute the upper and lower errors
            #NOTE that according to Tristan this is an under-estionation of the
            # errors!

            #NOTE some output is missing the errorbar columns!
            #So here I did a quick hack...

            try:
                verr_l, verr_h, serr_l, serr_h = np.genfromtxt(profilefit_file_path,
                        skip_header=1, usecols=(13,14,15,16), unpack=True)

                verr_l = verr_l[inner_ring_crop:-ring_crop]
                verr_h = verr_h[inner_ring_crop:-ring_crop]
                serr_l = serr_l[inner_ring_crop:-ring_crop]
                serr_h = serr_h[inner_ring_crop:-ring_crop]

                noerrorbar = False

            except:
                log.warning('Invalid number of columns in profile file! No errors computed.')

                try:
                    #Use the next data set...
                    verr_l, verr_h, serr_l, serr_h = np.genfromtxt(
                        rot_dir_list[i+1] + profile_file_name_list[i+1],
                        skip_header=1, usecols=(13,14,15,16), unpack=True)

                    verr_l = verr_l[inner_ring_crop:-ring_crop]
                    verr_h = verr_h[inner_ring_crop:-ring_crop]
                    serr_l = serr_l[inner_ring_crop:-ring_crop]
                    serr_h = serr_h[inner_ring_crop:-ring_crop]

                    noerrorbar = False

                except:
                    noerrorbar = True


            if profile == 'rotation':
                if noerrorbar:
                    lines.append(ax.step(rad, vrot, where='mid',
                        color=color_list[i], alpha=-0.05*i,
                        linewidth=2.5,
                        label='{0:s}'.format(label_list[i]))[0])
                
                else:
                    lines.append(ax.errorbar(rad, vrot, yerr=[verr_l, -verr_h],
                        #fmt='.', capsize=2, elinewidth=1.5, markersize=7.5,
                        linewidth=2.5, capsize=0, elinewidth=2.5,
                        color=color_list[i], alpha=1-0.05*i,
                        drawstyle = 'steps-mid',
                        label='{0:s}'.format(label_list[i])))

                    #lines.append(ax.bar(rad, vrot, yerr=[verr_l, -verr_h],
                    #    align='center', alpha=0.8, ecolor='black', capsize=10))

            elif profile == 'dispersion':
                if noerrorbar:
                    lines.append(ax.step(rad, srot, where='mid',
                        color=color_list[i], alpha=1.-0.05*i,
                        linewidth=2.5,
                        label='{0:s}'.format(label_list[i])))

                else:
                    lines.append(ax.errorbar(rad, srot, yerr=[serr_l, -serr_h],
                        linewidth=2.5, capsize=0, elinewidth=2.5,
                        color=color_list[i], alpha=1-0.05*i,
                        drawstyle = 'steps-mid',
                        label='{0:s}'.format(label_list[i])))

        else:
            rad_sd, surfdens, sd_err = np.genfromtxt(profilefit_file_path,
                    usecols=(0,3,4), unpack=True)

            rad_sd = rad_sd[inner_ring_crop:-ring_crop]
            surfdens = surfdens[inner_ring_crop:-ring_crop]
            sd_err = sd_err[inner_ring_crop:-ring_crop]

            lines.append(ax.errorbar(rad_sd, surfdens, yerr=sd_err,
                    linewidth=2.5, capsize=0, elinewidth=2.5,
                    color=color_list[i], alpha=1-0.05*i,
                    drawstyle = 'steps-mid',
                    label='{0:s}'.format(label_list[i])))
     
    if profile == 'rotation':
        ax.set_ylabel(r'v$_{rot}$ [km/s]', fontsize=18)
    elif profile == 'dispersion':
        ax.set_ylabel(r'$\sigma_{rot}$ [km/s]', fontsize=18)
    else:
        ax.set_ylabel(r'$\Sigma$ [Jy/beam $\times$ km/s]', fontsize=18)
        #ax.set_ylabel(r'$\Sigma$ [Jy/pixel $\times$ km/s]', fontsize=18)
        #Unit depends on the 3DBarolo file!
    
    ax.set_xlabel('Radius [arcsec]', fontsize=18)
    #ax.grid()

    if profile == 'rotation':
        #Add legend
        labels = [l.get_label() for l in lines]
        legend0 = ax.legend(lines, labels, loc='lower right',
            bbox_to_anchor= (0.9, 0.1),
            ncol=2, borderaxespad=0, frameon=True,
            fontsize=16, framealpha=1, fancybox=True, labelspacing=0.25,
            handletextpad=0.3, handlelength=1.5, columnspacing=0.5)

        #Add inner title
        t = ds.sdiagnostics.add_inner_title(ax, 'Rotation profile', loc=2,
            prop=dict(size=18))
        t.patch.set_ec("none")
        t.patch.set_alpha(0.5)

    elif profile == 'dispersion':
        #Add legend
        labels = [l.get_label() for l in lines]
        legend0 = ax.legend(lines, labels, loc='lower left',
            bbox_to_anchor= (0.1, 0.1),
            ncol=2, borderaxespad=0, frameon=True,
            fontsize=16, framealpha=1, fancybox=True, labelspacing=0.25,
            handletextpad=0.3, handlelength=1.5, columnspacing=0.5)

        #Add inner title
        t = ds.sdiagnostics.add_inner_title(ax, 'Dispersion profile', loc=1,
            prop=dict(size=18))
        t.patch.set_ec("none")
        t.patch.set_alpha(0.5)

    else:
        #Add legend
        labels = [l.get_label() for l in lines]
        legend0 = ax.legend(lines, labels, loc='lower left',
            bbox_to_anchor= (0.1, 0.1),
            ncol=2, borderaxespad=0, frameon=True,
            fontsize=16, framealpha=1, fancybox=True, labelspacing=0.25,
            handletextpad=0.3, handlelength=1.5, columnspacing=0.5)

        #Add inner title
        t = ds.sdiagnostics.add_inner_title(ax, 'Density profile', loc=1, prop=dict(size=18))
        t.patch.set_ec("none")
        t.patch.set_alpha(0.5)

    legend0.get_frame().set_linewidth(2);
    legend0.get_frame().set_edgecolor('black');

    plt.savefig(output_fname,bbox_inches='tight')
    plt.close()

def plot_angle_curves(rot_dir_list,
                    profile_file_name_list,
                    output_fname,
                    angle_type='inclination',
                    ring_crop=2,
                    inner_ring_crop = 0,
                    label_list=['?'],
                    color_list=[None]):
    """This is a simple function to plot different models fit on different deep
    imaging methods. The main curves this function can produce:

    - inclination curve
    - position angle curve

    This is a separate code form the `plot_profile_curves` function for a various
    resons, but mainly not to overcmplicate that function... man I should really
    modularise more...

    NOTE, that 3DBarolo generates the fit and this code just overplot the output of
    differet runs!

    Parameters
    ==========

    rot_dir_list: list of str
        The full path of each 3DBarolo output which under the fit text files live.

    profile_file_name_list: lost of strings
        The name of the profile file generated by 3DBarolo. As several fit cycles are possible,
        this can be te first of the final cycle. Also, the density profiles are
        outputted to a different file than the rotation curves. This si the file name
        that will be used for generating the plots!

    output_fname: str
        Name and full path of the images created.

    angle_type: str, optional
        The type of the angle profile plot generated.
        Currently, the following profiles are supported: 
        inclination, position_angle

    ring_crop: int, optional
        Number of the tilted ring model rings to exclude from the data, since the
        outter rings are fitted to the noisy data. The number of rings from the
        are excluded from the plots. If negative, rings starting from the inside
        are excluded and so this parameter has to be >= 0!

    inner_ring_crop: int, optional
        Number of rings from the inside, not included in the plots. Useful for the
        6km baseline modeling, as the innermost rings(s) can yield weird values...


    label list, list of strings, optional
        A string for each 3DBarolo output, that is displayed as a legend on the plot

    color_list: list of strings, optional
        The color for each 3DBarolo output on the plot

    Return
    ======
    output_image: file
        The image created
 
    """
    #Check the available profiles
    if angle_type not in ['inclination', 'position_angle']:
        raise TypeError('Invalid angle image requested!')
    
    N_sources = len(rot_dir_list)

    profile_file_name_list = initialise_argument_list(N_sources, profile_file_name_list)
    label_list = initialise_argument_list(N_sources, label_list)

    #Generate random colors if needed
    color_list = initialise_argument_list(N_sources, color_list)
    for i in range(0,N_sources):
        if color_list[i] == None:
            color_list[i] = "#{:06x}".format(random.randint(0, 0xFFFFFF)) #Generate random HEX color
     
    #Create plot
    fig = plt.figure(1, figsize=(8,5))
    ax = fig.add_subplot(111)

    lines = []

    for i in range(0,N_sources):
        profilefit_file_path = rot_dir_list[i] + profile_file_name_list[i]


        if angle_type == 'inclination':
            rad, ang = np.genfromtxt(profilefit_file_path, skip_header=1,
                                    usecols=(1,4), unpack=True)

        else:
            rad, ang = np.genfromtxt(profilefit_file_path, skip_header=1,
                                    usecols=(1,5), unpack=True)

        #Crop the last N ringfit
        rad = rad[inner_ring_crop:-ring_crop]
        ang = ang[inner_ring_crop:-ring_crop]

        #lines.append(ax.step(rad, ang, where='mid',
        #                color=color_list[i], alpha=1.-0.05*i,
        #                linewidth=2.5,
        #                label='{0:s}'.format(label_list[i]))[0])

        lines.append(ax.plot(rad, ang, '-', lw=2.5,
                        color=color_list[i], alpha=1.,
                        label='{0:s}'.format(label_list[i]))[0])

        ax.scatter(rad, ang, color=color_list[i], alpha=1.)

    if angle_type == 'inclination':
        ax.set_ylabel(r'i [deg]', fontsize=18)
    else:
        ax.set_ylabel(r'$\Phi$ [deg]', fontsize=18)
    
    ax.set_xlabel('Radius [arcsec]', fontsize=18)


    #Add legend
    labels = [l.get_label() for l in lines]
    if angle_type == 'inclination':
        legend0 = ax.legend(lines, labels, loc='upper right',
            bbox_to_anchor= (0.95, 0.95),
            ncol=2, borderaxespad=0, frameon=True,
            fontsize=16, framealpha=1, fancybox=True, labelspacing=0.25,
            handletextpad=0.3, handlelength=1.5, columnspacing=0.5)
    else:
        legend0 = ax.legend(lines, labels, loc='lower right',
            bbox_to_anchor= (0.95, 0.1),
            ncol=2, borderaxespad=0, frameon=True,
            fontsize=16, framealpha=1, fancybox=True, labelspacing=0.25,
            handletextpad=0.3, handlelength=1.5, columnspacing=0.5)



    if angle_type == 'inclination':
        #Add inner title
        t = ds.sdiagnostics.add_inner_title(ax, 'Inclination',
            loc=2, prop=dict(size=18))
    else: 
        t = ds.sdiagnostics.add_inner_title(ax, 'Position angle',
            loc=2, prop=dict(size=18))

    t.patch.set_ec("none")
    t.patch.set_alpha(0.5)

    legend0.get_frame().set_linewidth(2);
    legend0.get_frame().set_edgecolor('black');

    plt.savefig(output_fname,bbox_inches='tight')
    plt.close()


def plot_pv_diagram_triangle_plot(rot_dir_list,
                                pv_fits_name_base_list,
                                profile_file_name_list,
                                output_fname,
                                plot_type='residual',
                                vsys=None,
                                channelwidth=4,
                                centre_index=53,
                                edge_crop=11,
                                ring_crop=2,
                                inner_ring_crop=0,
                                S_rms_list=[0.001],
                                contour_levels=[1,2,4,8,16,32],
                                color_list=[None],
                                label_list=['?'],
                                ident_list=['?'] ):
    """This code generates the p-v diagram triange plots based on the output from
    3DBarolo. Note, that many parameters needs to be given as `hardcoded` input.

    This is because, 3DBarolo gets some parameters for plotting as hardcoded values.

    Also, I am jaded to write code mining all stuff out. However, from knowing
    the data, izt should be easy to provide the input required. Furthermore, all
    can be mined out manually from the 3DBarolo output.

    As the aim of such plots is to compare different pipeline setups, rather than
    different sources, the difference between the p-v diagrams and the fitted models
    are small. That is because the modelfitting is robust enough. Or at least
    we kinda see this.

    Three different type of plots can be generated: `data`, `model` and `residual`

    For each type, the main diagonal of the plot contains the corresponding p-v
    cubelets, while the non-dialgonal lower-triangle contains the difference of
    the cubelets. The contours are plotted on top of the main diagonal plots, and
    the fitted ring model points in case of creating the `model` plots

    Parameters
    ==========

    rot_dir_list: list of str
        The full path of each 3DBarolo output which under the fit text files live.

    profile_file_name_list: lost of strings
        The name of the profile file generated by 3DBarolo. As several fit cycles are possible,
        this can be te first of the final cycle. Also, the density profiles are
        outputted to a different file than the rotation curves. This si the file name
        that will be used for generating the plots!

    output_fname: str
        Name and full path of the images created.

    plot_type: str, optional
        The type of the p-v triangle plot generated. Currently, the following
        plots are supported: data, model and residual

    vsys: int, optional
        None by default, and the sytematics velocity is generated from the model.
        However, the user can generate plots with custom systematics velocity or
        if the fit sysvel is uncertain.

    channelwidth: float, optional
        The channelwidth of the cubes in km/s. Alternatively, it could have computed
        from the .fits files, but then we would need to know the redshift...
        This is needed to compute the velocity axes. Its unit should be [km/s]

    centre_index: int, optional
        The index alongside of the frequency axis of the reference velocity. This
        parameter needs to be set manually for the FIRTS .fits given. Note, that
        if this parameter is wrong, the sub-plots will be off-centered!

    edge_crop: int, optional
        Number of pixels cropped from the edges of the p-v plots. As the input
        .fits files are not equal in size, but generating the rtiangle-lot requires
        square figures, we might need to crop the edges of each plot to have
        matching size square subplots. If the crop is too small an Error is raised.
        Try to minimise this parameter to have the maximum size square subplots
        possible!

    ring_crop: int, optional
        Number of the tilted ring model rings to exclude from the data, since the
        outter rings are fitted to the noisy data. The number of rings from the
        are excluded from the plots. If negative, rings starting from the inside
        are excluded and so this parameter has to be >= 0!

    S_rms_list: list of floats, optional
        The RMS value of the input data which is used as a base level for the
        contours.The unit is in the native units of the cube, possibly in [Jy/beam]
        If only a single value is given, it is used for all p-v plots

    inner_ring_crop: int, optional
        Number of rings from the inside, not included in the plots. Useful for the
        6km baseline modeling, as the innermost rings(s) can yield weird values...

    contour_levels: list of floats, optional
        The contour levels in terms of `S_rms` to be drawn to the data and model. 

    label_list, list of strings, optional
        A string for each 3DBarolo output, that is displayed a s alegend on the plot

    ident_list: list of string, optional
        A list of single character identications taht is dispalyed on the lower
        triangle plots to identicate the difference.

    color_list: list of strings, optional
        The color for each 3DBarolo output on tha plot



    """
    N_sources = len(rot_dir_list)

    profile_file_name_list = initialise_argument_list(N_sources, profile_file_name_list)
    label_list = initialise_argument_list(N_sources, label_list)
    ident_list = initialise_argument_list(N_sources, ident_list)
    S_rms_list = initialise_argument_list(N_sources, S_rms_list)

    #Generate random colors if needed
    color_list = initialise_argument_list(N_sources, color_list)
    for i in range(0,N_sources):
        if color_list[i] == None:
            color_list[i] = "#{:06x}".format(random.randint(0, 0xFFFFFF)) #Generate random HEX color
 
    #NOTE only creating the plot along the major axis of the galaxy!

    #=== Get the common smallest size for all p-v diagrams
    max_size = np.inf
    for i in range(0,N_sources):
        pv_fits = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] + '_pv_a.fits'
        #pv_fits = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] + 'mod_pv_a_local.fits'
                    
        pv_data_min_size = np.amin(np.shape(fits.open(pv_fits)[0].data))

        if pv_data_min_size < max_size:
            max_size = pv_data_min_size

    #Define the width of the sub-square imaged
    #edge_crop = 11

    #Make max_size to an even number so the sub-squares can be odd sized
    if max_size & 1:
        max_size -= 1 #Odd
    else:
        pass #even

    width = int((max_size - (2 * edge_crop)) / 2)

    #The expected size is
    expected_size = 1 + 2 * width

    #To get the reference pixel for the x axis
    fref = 0
    #centre_index = 53 #The reference pixel for the systematic velocity

    #Systematics velocity
    #vsys=1246
    #channelwidth = 4.

    if vsys == None:
        #Use the first inputs systematics velocity
        profilefit_file_path = rot_dir_list[0] + profile_file_name_list[0]

        vsys = np.genfromtxt(profilefit_file_path, skip_header=1,
                            usecols=(11), unpack=True)[0]



    #=== Creates the model list
    model_list = []
    for i in range(0,N_sources):
        if plot_type == 'data':
            pv_fits = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] \
                + '_pv_a.fits'
        elif plot_type == 'model':
            pv_fits = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] \
                + 'mod_pv_a_local.fits'

        elif plot_type == 'residual':
            pv_fits = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] \
                + '_pv_a.fits'
 
            pv_fits_model = rot_dir_list[i] + 'pvs/' + pv_fits_name_base_list[i] \
                + 'mod_pv_a_local.fits'

        #Find CRPIX1 & CRPIX2 and crop the image around them into a square with
        # odd number of pixels both side
        pv_model_header = fits.open(pv_fits)[0].header

        crpix1 = np.int(pv_model_header['CRPIX1'])
        crpix2 = np.int(pv_model_header['CRPIX2'])

        #Check the values
        crval1 = pv_model_header['CRVAL1']
        crval2 = pv_model_header['CRVAL2']

        cdelt1 = pv_model_header['CDELT1']
        cdelt2 = pv_model_header['CDELT2']

        
        #Get the reference pixel from a reference frequency 
        # I think it is actually the x axis...
        if crpix2 < 0:
            if fref == 0:
                data_shape2 = np.shape(fits.open(pv_fits)[0].data)[1]

                if centre_index == None:
                    if data_shape2 & 1:
                        centre_index = int((data_shape2 - 1) / 2) - 3
                        #print(centre_index)
                    
                    else:
                        centre_index = int(data_shape2 / 2)

                fref = crval2 + ((centre_index + np.fabs(crpix2)) * cdelt2)

            #Now get the reference pixels
            while fref > crval2:
                crpix2 += 1
                crval2 += cdelt2

        #python indexing to get the reference pixels to the centre
        if plot_type != 'residual':
            model_list.append(fits.open(pv_fits)[0].data[int(crpix2 - width): \
                int(crpix2 + 1 + width), int(crpix1 - width):int(crpix1 + 1 + width)])
        else:
            pv_data = fits.open(pv_fits)[0].data[int(crpix2 - width): \
                int(crpix2 + 1 + width), int(crpix1 - width):int(crpix1 + 1 + width)]
            
            pv_model = fits.open(pv_fits_model)[0].data[int(crpix2 - width): \
                int(crpix2 + 1 + width), int(crpix1 - width):int(crpix1 + 1 + width)]
            
            diffmap = np.subtract(pv_data, pv_model)

            model_list.append(diffmap)


        if np.shape(model_list[i])[0] != np.shape(model_list[i])[1] or np.shape(model_list[i])[0] != expected_size:
            raise ValueError('Some p-v shapes are smaller than expected, pleas increase the edge_crop parameter!')


        #=== Set the image frame using the first plot
        #NOTE that the coordiantes used should be okay for all pot, but really only for
        # the first plot...
        if i == 0:
            xmin_wcs = ((int(crpix1 - width) - crpix1) * cdelt1 + crval1) * 3600
            xmax_wcs = ((int(crpix1 + 1 + width) - crpix1) * cdelt1 + crval1) * 3600

            zmin_wcs = vsys - (channelwidth * width)
            zmax_wcs = vsys + (channelwidth * (width + 1))

            ext = [xmin_wcs, xmax_wcs, zmin_wcs, zmax_wcs]

            #Need to be able to plot the p-v diagram data with imshow as
            # square images (it is an NxN image anyway)
            imshow_aspect = (xmax_wcs - xmin_wcs) / (zmax_wcs - zmin_wcs)

    #=== get the common color map for the difference maps
    c_max = -np.inf
    c_min = np.inf
    for i in range(0,N_sources):
        for j in range(0,N_sources):
            if i>j:
                diffmap = np.subtract(model_list[j], model_list[i])
                c_max_diff = np.amax(diffmap)
                c_min_diff = np.amin(diffmap)

                if c_max_diff > c_max:
                    c_max = c_max_diff
    
                if c_min_diff < c_min:
                    c_min = c_min_diff


    c_diff = np.amax([np.fabs(c_min), np.fabs(c_max)])

    #Set the contour levels
    #cont = 0.00392164
    #v = np.array([1,2,4,8,16,32,64])*cont
    
    #cont = S_rms
    #v = np.array(contour_levels) * S_rms

    #=== Create the plot
    fig, axes = plt.subplots(figsize=(2 + 4 * N_sources, 2 + 4 * N_sources),
          sharex=True, sharey=True, ncols=N_sources, nrows=N_sources)
    
    for i in range(0,N_sources):
        for j in range(0,N_sources):
            if i<j:
                axes[i,j].set_axis_off() #This does not work with projection
               
            else:
                if i == j:
                    #Background data in black and white
                    axes[i,j].imshow(model_list[i], origin='lower',
                            cmap='Greys', extent=ext, aspect=imshow_aspect)

                    #The vsys and 0 dashed lines
                    axes[i,j].axhline(vsys, ls='--', lw=2, color=outlier_color, alpha=1.)
                    axes[i,j].axvline(0, ls='--', lw=2, color=outlier_color, alpha=1.)

                    axes[i,j].contour(model_list[i],
                                np.array(contour_levels) * S_rms_list[i],
                                origin='lower', alpha=1.,
                                linewidths=1.5,colors=color_list[i], extent=ext)

                    ax2 = axes[i,j].secondary_yaxis('right',
                            functions=(lambda x: x - vsys, lambda x: x -vsys)) 

                    ax2.set_ylabel(r'$\Delta$v$_{opt}}$ [km/s]', fontsize=18)

                    #Plot the fitted model rotation curve values
                    if plot_type == 'model':
                        profilefit_file_path = rot_dir_list[i] + profile_file_name_list[i]

                        rad, vrot, srot = np.genfromtxt(profilefit_file_path, skip_header=1,
                                        usecols=(1,2,3), unpack=True)

                        #Crop the last N ringfit
                        #ring_crop = 2
                        rad = rad[inner_ring_crop:-ring_crop]
                        vrot = vrot[inner_ring_crop:-ring_crop]
                   
                        radius = np.concatenate((-rad,rad))
                        vrot1 = vsys + vrot
                        vrot2 = vsys - vrot
                        vlos = np.concatenate((vrot1,vrot2))

                        axes[i,j].plot(radius, vlos, 'o', color=c3,markersize=5)

                    #Add inner title
                    t = ds.sdiagnostics.add_inner_title(axes[i,j], 
                            str(label_list[i] + ' ({0:s})'.format(ident_list[i])),
                            loc=2, prop=dict(size=16,color=color_list[i]))
                    t.patch.set_ec("none")
                    t.patch.set_alpha(1.)

                if i != j:
                    #Difference maps
                    mom_ax = axes[i,j].imshow(np.subtract(model_list[j],model_list[i]),
                            origin='lower', extent=ext, aspect=imshow_aspect,
                            vmin=-c_diff, vmax=c_diff, cmap=_CMAP2)

                    #The vsys and 0 dashed lines
                    #Should be in grey, but not because of cividis...
                    axes[i,j].axhline(vsys, ls='--', lw=2, color='black', alpha=0.6)
                    axes[i,j].axvline(0, ls='--', lw=2, color='black', alpha=0.6)


                    #Add colorbar
                    cbaxes = inset_axes(axes[i,j], width="65%", height="6.%", 
                            loc='upper right') 
                    cb = plt.colorbar(mom_ax, cax=cbaxes, orientation='horizontal')

                    #set ticks and label left side
                    cbaxes.yaxis.set_ticks_position('left')
                    
                    cb.ax.tick_params(colors='black', rotation=18)
                  
                    cb.ax.set_ylabel(r'$\Delta$S', color='black',
                            fontsize = 18, labelpad=10)

                    #Add inner title
                    t = ds.sdiagnostics.add_inner_title(axes[i,j], 
                            str(r'({0:s} - {1:s})'.format(ident_list[j],ident_list[i])),
                            loc=3, prop=dict(size=16,color='black'))
                    t.patch.set_ec("none")
                    t.patch.set_alpha(1.)

            if i == (N_sources - 1):
                axes[i,j].set_xlabel('Offset [arcsec]', fontsize=18)
                axes[i,j].tick_params(axis='x', length=matplotlib.rcParams['xtick.major.size'])
 
            if j == 0:
                axes[i,j].set_ylabel(r'v$_{opt}}$ [km/s]', fontsize=18)
                axes[i,j].tick_params(axis='y', length=matplotlib.rcParams['xtick.major.size'])

    #Some style settings
    plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=0.0, hspace=0.0)

    plt.savefig(output_fname, bbox_inches='tight')
    plt.close()
    

#=== MAIN ===
if __name__ == "__main__"
    pass