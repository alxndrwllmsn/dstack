"""This is an example Snakemake makefile to
run some grid stacking without slurm support so far
"""

#=== Define variables for the pipeline ===
#Absolute path to working directory
MS_DIR = '/home/krozgonyi/dstack/pipelines/beam_17_dstcak_grid_stackng_pipeline/measurement_sets'
#MS_DIR = '/mnt/hidata2/dingo/pilot/uvgrid'
WORKING_DIR = os.getcwd() #YandaSoft needs absolute paths

MIN_CHANNEL = 10
MAX_CHANNEL = 12

#MIN_CHANNEL = 6377
#MAX_CHANNEL = 6476

N_CHANNELS = MAX_CHANNEL - MIN_CHANNEL + 1 #Both the min and the max are included thats why we have the +1

#N_CORES = 1
#N_CHANNELS = N_CORES

#This maps the irregularry names input MS to a regular naming scheme
ORIGINAL_MS_MAPPING = {'1':'SB10991/scienceData_SB10991_G23_T0_B_06.beam17_SL',
                        '2':'SB11000/scienceData_SB11000_G23_T0_B_03.beam17_SL'}

#Slurm logfiles firetory
LOGDIR = '{0:s}/rule_logs'.format(WORKING_DIR) #Have to be the same as the output defined in the config.yaml file!!!

#Envinroment setup
ENV_SETUP = 'source /home/krozgonyi/.bashrc; dstack_env_setup; '

#=== Define rules ===
#ruleorder: create_log_dir > create_mssplit_configfile

#Master rule:
rule all:
    input:
        '{0:s}'.format(LOGDIR), #Make sure that the log dir exist before running => can not create this with a rule as snakemake wants to log the rule to the same folder through slurm!
        '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/image.deep.restored'
        #'{0:s}'.format(WORKING_DIR) + '/mssplit_config/mssplit_config_night_1.in', '{0:s}'.format(WORKING_DIR) +  '/mssplit_config/mssplit_config_night_2.in'#only create mssplit_configfile
        #'{0:s}'.format(WORKING_DIR) + 'measurement_sets/night_1.ms','{0:s}'.format(WORKING_DIR) + 'measurement_sets/night_2.ms' #split ms

rule create_mssplit_configfile:
    input:
        logdir = '{0:s}'.format(LOGDIR),
        MS =  lambda wildcards: '{0:s}/{1:s}.ms'.format(MS_DIR,ORIGINAL_MS_MAPPING[wildcards.night_index])
    output:
        '{0:s}'.format(WORKING_DIR) + '/mssplit_config/mssplit_config_night_{night_index}.in'
    params:
        output_MS = 'measurement_sets/night_{night_index}.ms'
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        'echo vis={input.MS} >> ' + '{0:s}'.format(WORKING_DIR) + '/{output};' + \
        'echo outputvis={0:s}'.format(WORKING_DIR) + '/{params.output_MS} >> ' + '{0:s}'.format(WORKING_DIR) + '/{output};' + \
        'echo channel={0:d}-{1:d} >> '.format(MIN_CHANNEL,MAX_CHANNEL) + '{0:s}'.format(WORKING_DIR) + '/{output};'

rule split_ms:
    input:
        MS =  lambda wildcards: '{0:s}/{1:s}.ms'.format(MS_DIR,ORIGINAL_MS_MAPPING[wildcards.night_index]),
        mssplit_config = '{0:s}'.format(WORKING_DIR) + '/mssplit_config/mssplit_config_night_{night_index}.in'
    output:
        directory('{0:s}'.format(WORKING_DIR) + '/measurement_sets/night_{night_index}.ms')
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        ENV_SETUP + \
        #'echo mssplit -c ./{input.mssplit_config}; mkdir {output}' #For testing
        'mssplit -c {0:s}'.format(WORKING_DIR) + '{input.mssplit_config}'#Redirect STDERR and STDOUT to the logfile

rule create_parset:
    input:
        MS = '{0:s}'.format(WORKING_DIR) + '/measurement_sets/night_{night_index}.ms',
        template_parset = '{0:s}'.format(WORKING_DIR) + '/template_parset.in'
    output:
        '{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/dumpgrid_parset.in'
    params:
        op = 'test/night_{night_index}', #Setup a variable using a wildcard
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        'dparset -i Cimager -n image.dumpgrid -g WProject -op {params.op} \
-pn dumpgrid_parset.in -t {input.template_parset} -tn image.sim_PC -a dataset={input.MS}'

rule first_pass_imaging:
    input:
       '{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/dumpgrid_parset.in'
    output:
        #directory('test/night_{night_index}/night_{night_index}.grid')
        directory('{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/grid.wr.1.dumpgrid'),
        directory('{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/psfgrid.wr.1.dumpgrid'),
        directory('{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/pcf.wr.1.dumpgrid')
    params:
        yanda_logfile = 'logfile_dumpgrid_night_{night_index}.log',
        night_subdir = '{0:s}'.format(WORKING_DIR) + '/test/night_{night_index}/' #Need to run imaging inside the directory
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        'echo cd {params.night_subdir}  && echo ' + 'mpirun -np {0:d}'.format(N_CHANNELS+1) + ' imager -c dumpgrid_parset.in > ./{params.yanda_logfile}; mkdir {output}' #For testing
        #'cd {params.night_subdir}  && ' + 'mpirun -np {0:d}'.format(N_CHANNELS+1) + ' imager -c dumpgrid_parset.in > ./{params.yanda_logfile}'#This is how to mix wildcards and variables in the shell execution string

rule grid_stacking:
    input:
        grid = ['{0:s}'.format(WORKING_DIR) + '/test/night_{0:s}/grid.wr.1.dumpgrid'.format(night_index) for night_index in ORIGINAL_MS_MAPPING.keys()],
        psfgrid = ['{0:s}'.format(WORKING_DIR) + '/test/night_{0:s}/psfgrid.wr.1.dumpgrid'.format(night_index) for night_index in ORIGINAL_MS_MAPPING.keys()],
        pcf = ['{0:s}'.format(WORKING_DIR) + '/test/night_{0:s}/pcf.wr.1.dumpgrid'.format(night_index) for night_index in ORIGINAL_MS_MAPPING.keys()] #We define the relgular naming scheme used in our mapping for the input MS!
    output:
        grid = directory('{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/grid.deep'),
        psfgrid = directory('{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/psfgrid.deep'),
        pcf = directory('{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/pcf.deep')
    params:
        cp = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids',
        cn_grid = 'grid.deep',
        cn_psfgrid = 'psfgrid.deep',
        cn_pcf = 'pcf.deep'
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        #For testing
        'echo dstacking -cl {input.grid} -cp {params.cp} -cn {params.cn_grid} -c; mkdir {output.grid};\
        echo dstacking -cl {input.psfgrid} -cp {params.cp} -cn {params.cn_psfgrid} -c; mkdir {output.psfgrid}; \
        echo dstacking -cl {input.pcf} -cp {params.cp} -cn {params.cn_pcf} -c; mkdir {output.pcf};'
        #For actual running the pipeline
        #'dstacking -cl {input.grid} -cp {params.cp} -cn {params.cn_grid} -c;\
        #dstacking -cl {input.psfgrid} -cp {params.cp} -cn {params.cn_psfgrid} -c; \
        #dstacking -cl {input.pcf} -cp {params.cp} -cn {params.cn_pcf} -c;'

rule create_deep_parset:
    input:
        grid = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/grid.deep',
        psfgrid = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/psfgrid.deep',
        pcf = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/pcf.deep',
        template_parset = '{0:s}'.format(WORKING_DIR) + '/template_parset.in'
    output:
        '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/cdeconvolver_{image_names}.in' #Need to have a wildcard in the output so I can pass it to a variable
    params:
        image_names = '{image_names}' #If I don't want to hardcode it in case I want to scale upt to beams
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        'dparset -i Cdeconvolver -n {params.image_names} -g WProject -op test/stacked_grids \
-pn cdeconvolver_{params.image_names}.in -t {input.template_parset} -tn image.sim_PC -a grid={input.grid} \
psfgrid={input.psfgrid} pcf={input.pcf}'

rule deep_imaging:
    input:
        grid = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/grid.deep',
        parset = '{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/cdeconvolver_{image_names}.in'
    output:
        directory('{0:s}'.format(WORKING_DIR) + '/test/stacked_grids/{image_names}.restored')
    params:
        yanda_logfile = 'logfile_cdeconvolver_{image_names}.log',
        parset_name = 'cdeconvolver_{image_names}.in'
    resources:
        time_min=300,
        mem_mb=1000,
        cpus=1
    shell:
        'echo cd {0:s}'.format(WORKING_DIR) + '/test/stacked_grids/ && echo mpirun -np {0:d}'.format(N_CHANNELS) + ' cdeconvolver-mpi -c {params.parset_name} > ./{params.yanda_logfile}; mkdir test/stacked_grids/image.deep.restored' #for testing
        #'cd {0:s}'.format(WORKING_DIR) + '/test/stacked_grids/ && mpirun -np {0:d}'.format(N_CHANNELS) + ' cdeconvolver-mpi -c {params.parset_name} > ./{params.yanda_logfile}'
